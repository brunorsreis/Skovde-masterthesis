#!/usr/bin/env python
# coding: utf-8

# In[1]:


import os
import json
import re
import warnings
import oracledb
import pdfplumber
import pandas as pd
import matplotlib.pyplot as plt
from collections import Counter
from tkinter import Tk, filedialog
from sentence_transformers import SentenceTransformer
from IPython.display import display, HTML
from IPython.core.interactiveshell import InteractiveShell
import subprocess
import signal
import gc

# Close previous Jupyter Notebook sessions (Unix/Linux/macOS)
import os
import json
import re
import warnings
import oracledb
import pdfplumber
import pandas as pd
import matplotlib.pyplot as plt
from collections import Counter
from tkinter import Tk, filedialog
from sentence_transformers import SentenceTransformer
from IPython.display import display, HTML
from IPython.core.interactiveshell import InteractiveShell
import subprocess
import signal
import gc

# üîí Session cleanup: Close old Jupyter notebooks and Python3.11 processes
def close_jupyter_sessions():
    try:
        result = subprocess.run(['pgrep', '-f', 'jupyter-notebook'], capture_output=True, text=True)
        pids = result.stdout.strip().split('\n')
        for pid in pids:
            if pid.strip():
                os.kill(int(pid), signal.SIGTERM)
        print("‚úÖ Closed previous Jupyter Notebook sessions.")
    except Exception as e:
        print(f"‚ö†Ô∏è Failed to close Jupyter sessions: {e}")

def close_python311_sessions():
    try:
        result = subprocess.run(['pgrep', '-f', 'python3.11'], capture_output=True, text=True)
        pids = result.stdout.strip().split('\n')
        for pid in pids:
            if pid.strip() and int(pid) != os.getpid():
                os.kill(int(pid), signal.SIGTERM)
        print("‚úÖ Closed previous python3.11 processes.")
    except Exception as e:
        print(f"‚ö†Ô∏è Failed to close python3.11 processes: {e}")

close_jupyter_sessions()
close_python311_sessions()


# UI configuration for Jupyter
InteractiveShell.ast_node_interactivity = "all"
display(HTML('''
<style>
.output_scroll {
    height: auto !important;
    max-height: none !important;
}
.output {
    overflow-y: visible !important;
}
</style>
'''))

warnings.filterwarnings("ignore")
pd.set_option('display.max_colwidth', None)
pd.set_option('display.max_rows', None)
pd.set_option('display.width', 0)

embedder = SentenceTransformer('all-MiniLM-L6-v2')

connection = oracledb.connect(
    user="VECDEMO",
    password="Oracle4U",
    dsn="localhost:1522/FREEPDB1"
)
cursor = connection.cursor()

cursor.execute("""
BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE forensic_vectors';
EXCEPTION
    WHEN OTHERS THEN NULL;
END;
""")
cursor.execute("""
CREATE TABLE forensic_vectors (
    id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    filename VARCHAR2(255),
    content CLOB,
    embedding VECTOR(384)
)
""")

risk_info = {
    "email": {
        "description": "Email addresses can be used for spam, phishing, impersonation, and credential stuffing.",
        "risks": [
            "Used in phishing attacks",
            "Credential stuffing with leaked passwords",
            "Impersonation or identity theft"
        ],
        "mitigation": [
            "Mask or obfuscate emails",
            "Avoid storing emails in plain text",
            "Limit sharing in public documents"
        ]
    },
    "phone": {
        "description": "Phone numbers can be used for scams, SIM swapping, or phishing (smishing).",
        "risks": [
            "Targeted smishing attacks",
            "SIM swapping for MFA hijacking",
            "Privacy violations or spam"
        ],
        "mitigation": [
            "Redact or anonymize phone numbers",
            "Use work numbers, not personal ones",
            "Avoid including in exposed files"
        ]
    },
    "credit_card": {
        "description": "Card numbers can lead to financial fraud or compliance issues.",
        "risks": [
            "Unauthorized transactions",
            "PCI DSS noncompliance penalties",
            "Account compromise"
        ],
        "mitigation": [
            "Never store full card numbers",
            "Use tokenization or encryption",
            "Follow PCI compliance"
        ]
    },
    "passwords": {
        "description": "Exposed passwords risk full account takeover and data breaches.",
        "risks": [
            "Account hijacking",
            "Internal privilege escalation",
            "Credential stuffing"
        ],
        "mitigation": [
            "Never store or share passwords in files",
            "Use vaults/password managers",
            "Audit and rotate exposed passwords"
        ]
    },
    "ip_address": {
        "description": "IP addresses can be used for attacks, geolocation, or scanning.",
        "risks": [
            "Targeted port scanning or DDoS",
            "Geolocation and traffic tracking",
            "VPN/IP range enumeration"
        ],
        "mitigation": [
            "Avoid exposing internal IPs",
            "Use NAT/proxies to shield IPs",
            "Monitor network logs for abuse"
        ]
    }
}

def detect_sensitive_info(text: str) -> list:
    patterns = {
        "email": r'[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+',
        "phone": r'\+?\d[\d\s.-]{7,}\d',
        "credit_card": r'\b(?:\d[ -]*?){13,16}\b',
        "passwords": r'(?i)\b(password|pwd|pass)\s*[:=]\s*\S+',
        "ip_address": r'\b(?:\d{1,3}\.){3}\d{1,3}\b'
    }
    findings = []
    for label, pattern in patterns.items():
        matches = re.findall(pattern, text)
        if matches:
            findings.append((label, matches))
    return findings

def read_file_content(file_path: str) -> str:
    ext = os.path.splitext(file_path)[1].lower()
    try:
        if ext == ".txt":
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                return f.read()
        elif ext == ".pdf":
            with pdfplumber.open(file_path) as pdf:
                return "\n".join(page.extract_text() or '' for page in pdf.pages)
        elif ext == ".csv":
            try:
                df = pd.read_csv(file_path, engine="python", on_bad_lines='skip')
                return df.to_string()
            except Exception as e:
                print(f"Error reading CSV {file_path}: {e}")
                return ""
        elif ext == ".json":
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                return json.dumps(json.load(f), indent=2)
        else:
            return ""
    except Exception as e:
        print(f"Error reading {file_path}: {e}")
        return ""

def embed_file(file_path: str):
    content = read_file_content(file_path)
    if not content.strip():
        raise ValueError(f"No readable content in: {file_path}")
    embedding = embedder.encode(content).tolist()
    return content, embedding

def insert_file(file_path):
    filename = os.path.basename(file_path)
    content, vector = embed_file(file_path)
    vector_str = json.dumps(vector)
    cursor.setinputsizes(embedding=oracledb.DB_TYPE_CLOB)
    cursor.execute(
        "INSERT INTO forensic_vectors (filename, content, embedding) VALUES (:filename, :content, TO_VECTOR(:embedding))",
        {
            "filename": filename,
            "content": content,
            "embedding": vector_str
        }
    )
    connection.commit()

def select_directory():
    root = Tk()
    root.withdraw()
    return filedialog.askdirectory(title="Select Folder with Files")

samples_path = select_directory()
allowed_exts = {".txt", ".pdf", ".csv", ".json"}
for file in os.listdir(samples_path):
    if os.path.splitext(file)[1].lower() in allowed_exts:
        insert_file(os.path.join(samples_path, file))

def semantic_search(query: str, top_k: int = 5):
    q_vector = embedder.encode(query).tolist()
    q_vector_str = json.dumps(q_vector)
    cursor.setinputsizes(embedding=oracledb.DB_TYPE_CLOB)
    cursor.execute(
        """
        SELECT filename, content, VECTOR_DISTANCE(embedding, TO_VECTOR(:embedding)) AS similarity
        FROM forensic_vectors ORDER BY similarity DESC FETCH FIRST :top_k ROWS ONLY
        """,
        {
            "embedding": q_vector_str,
            "top_k": top_k
        }
    )
    return cursor.fetchall()

all_findings = []
results = semantic_search("password list")

for fname, content, score in results:
    if hasattr(content, "read"):
        content = content.read()

    findings = detect_sensitive_info(content)
    for category, matches in findings:
        all_findings.extend([category] * len(matches))

    if findings:
        print(f"\nüîê [{score:.2f}] {fname}")
        for category, matches in findings:
            print(f"\nüìå {category.upper()} [{len(matches)} found]")
            print("Matches:")
            for match in matches:
                print(f"   ‚Ä¢ {match}")

            info = risk_info.get(category)
            if info:
                print("\nüõ†Ô∏è  What hackers can do:")
                for risk in info["risks"]:
                    print(f"   - {risk}")
                print("\nüîê Mitigation strategies:")
                for fix in info["mitigation"]:
                    print(f"   - {fix}")
                print(f"\n‚ÑπÔ∏è  Summary: {info['description']}")
            print("-" * 70)
    else:
        print(f"\n‚úÖ [{score:.2f}] {fname} ‚Äì No sensitive data found.")

if all_findings:
    counter = Counter(all_findings)
    plt.figure(figsize=(10, 6))
    bars = plt.bar(counter.keys(), counter.values(), color='darkred')
    plt.title("Sensitive Data Categories Found", fontsize=14)
    plt.xlabel("Category", fontsize=12)
    plt.ylabel("Occurrences", fontsize=12)
    plt.grid(True, linestyle="--", alpha=0.5)

    for bar in bars:
        yval = bar.get_height()
        plt.text(bar.get_x() + bar.get_width()/2, yval + 0.2, int(yval),
                 ha='center', va='bottom', fontsize=10, fontweight='bold')

    plt.tight_layout()
    plt.show()
else:
    print("\n‚úÖ No sensitive information detected in any file.")

# Cleanup
try:
    if cursor:
        cursor.close()
    if connection:
        connection.close()
    print("\n‚úÖ Oracle connection closed.")
except Exception as e:
    print(f"‚ö†Ô∏è Error closing connection: {e}")

try:
    import tkinter
    tkinter._default_root = None
except Exception:
    pass

gc.collect()
print("üßπ All resources cleaned up. Safe to exit or rerun.")

